#!/bin/sh

startup() {
    for SOCKNAME in $EMACS_DAEMONS; do
	emacs --daemon="$SOCKNAME"
	# doesn't restore window setup, but buffers are there
	if [ "$1" = "state" ]; then
	    emacsclient -s "$SOCKNAME" -e '(desktop-read)'
	fi
    done
}

reboot() {
    purge "$1"
    startup "$1"
}

purge() {
    save="$1"
    set IFS='\n';
    # for SOCKNAME in $EMACS_DAEMONS; do # purge default daemons (work, personal, default)
    for SOCKNAME in $(ps -x | grep "emacs --daemon" | head -n -1 | awk -F'=' '{print $2}'); do # purge all daemons
	if [ "$save" = "state" ]; then
	    emacsclient -s "$SOCKNAME" -e '(myrc/kill-emacs t nil)'
	else
	    emacsclient -s "$SOCKNAME" -e '(myrc/kill-emacs nil nil)'
	fi
    done
    unset IFS;
}

new() {
    # List custom workspaces instead of just EMACS_DAEMONS
    TMP_FILE="/tmp/em.daemons"
    echo $EMACS_DAEMONS | sed 's/ /\n/g' > $TMP_FILE
    ps -x | grep "emacs --daemon" | awk -F '=' 'NR>1 {print last} {last=$2}' >> $TMP_FILE
    SOCKNAME="$(cat $TMP_FILE | sort | uniq | rofi -m -4 -dmenu -p "Workspace")"

    if [ -n "$SOCKNAME" ]; then
	# if SOCKNAME does not exist, spin up an emacs server under that name
	if [ "$(ps -x | grep "emacs --daemon=$SOCKNAME" | wc -l)" = 1 ]; then
	    emacs --daemon="$SOCKNAME"
	fi
	emacsclient -c -socket-name="$SOCKNAME"
    fi
}

# Behaviour changes when ran interactively (i.e. go through systemctl).
# When $2 is set to "service" the command is considered to be ran in non-interactive mode.
# When $3 is set to "state" the state of emacs desktops is saved
source "$HOME/.config/env.sh"
SERVICE="emacs.service"
case "$1" in
    s | startup) startup "$2" ;;
    p | purge  ) purge "$2" ;;
    r | reboot ) reboot "$2" ;;
    n | new) new ;;
    *) emacsclient -s default -r "$1" ;;
esac
