#!/bin/sh

startup() {
    source "$HOME/.config/env"
    for SOCKNAME in $EMACS_DAEMONS; do
	emacs --daemon="$SOCKNAME"
	# doesn't restore frame setup, run it manually
	# if [ "$1" = "state" ]; then
	#     emacsclient -s "$SOCKNAME" -e '(desktop-read)'
	# fi
    done
}

reboot() {
    if [ "$1" = "state" ]; then
	purge "state"
    else
	purge
    fi
    startup
}

purge() {
    save="$1"
    set IFS='\n';
    for SOCKNAME in $(ps -x | grep "emacs --daemon" | head -n -1 | awk -F'=' '{print $2}'); do
	if [ "$save" = "state" ]; then
	    emacsclient -s "$SOCKNAME" -e '(myrc/kill-emacs t)'
	else 
	    emacsclient -s "$SOCKNAME" -e '(myrc/kill-emacs nil)'
	fi
    done
    unset IFS;
}

new() {
    SOCKNAME="$(echo $EMACS_DAEMONS | sed 's/ /\n/g' | rofi -m -4 -dmenu -p "Workspace")"
    if [ -n "$SOCKNAME" ]; then
        if [ "$(ps -x | grep "emacs --daemon=$SOCKNAME" | wc -l)" = 1 ]; then
            emacs --daemon="$SOCKNAME"
        fi
        emacsclient -c -socket-name="$SOCKNAME"
    fi
}

# Behaviour changes when ran interactively (i.e. go through systemctl).
# When $2 is set to "service" the command is considered to be ran in non-interactive mode.
# When $3 is set to "state" the state of emacs desktops is saved
SERVICE="emacs.service"
case "$1" in
    # s | startup) [ "$2" = "service"] && _st "$3" || startup "$2" ;;
    # p | purge  ) [ "$2" = "service"] && _pu "$3" || purge "$2" ;;
    # r | reboot ) [ "$2" = "service"] && _rb "$3" || reboot "$2" ;;
    s | startup) startup "$2" ;;
    p | purge  ) purge "$2" ;;
    r | reboot ) reboot "$2" ;;
    n | new) new ;;
    *) emacsclient -s server -c $1 ;;
esac
    
